esphome:
  name: entrance_lock
  platform: ESP8266
  board: d1_mini_pro

  includes:
    - d1motor.h
    - lock_controller.h

  # XXX
  arduino_version: dev

  on_boot:
    - script.execute: delayed_lockctl_setup_scr

substitutions:
  uname: Entrance Lock

wifi:
  networks: !secret wifi_networks

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "${uname} Fallback Hotspot"
    password: !secret wifi_ap_passwd

captive_portal:

# Enable logging
logger:

debug:

# Enable Home Assistant API
api:
  password: !secret api_password
  reboot_timeout: 5min
  services:
    - service: lock
      then:
        - logger.log: "requested to lock"
        - script.execute: lock_scr

    - service: unlock
      then:
        - logger.log: "requested to unlock"
        - script.execute: unlock_scr

    - service: reset_counters
      then:
        - globals.set:
            id: gv_lock_cnt
            value: '0'
        - globals.set:
            id: gv_unlock_cnt
            value: '0'

ota:
  password: !secret ota_password

web_server:
  auth:
    username: admin
    password: !secret web_password

prometheus:

i2c:
  id: i2c_bus
  scl: D1
  sda: D2

time:
  - platform: homeassistant
    id: esp_time
  - platform: sntp
    id: ntp_time
    timezone: Europe/Moscow

globals:
  - id: gv_lock_cnt
    type: uint32_t
    restore_value: yes
    initial_value: '0'
  - id: gv_unlock_cnt
    type: uint32_t
    restore_value: yes
    initial_value: '0'
  - id: gv_latch_mode
    type: bool
    restore_value: yes
    initial_value: "true"
  - id: gv_int_open_enabled
    type: bool
    restore_value: yes
    initial_value: "true"
  - id: gv_ext_open_enabled
    type: bool
    restore_value: yes
    initial_value: "true"

custom_component:
  - id: lockctl
    lambda: |-
      auto m = static_cast<D1Motor*>(id(lock_motor));
      auto ctl = new LockController(
        *m, *id(lockctl_on_state_change_scr),
        *id(h_locked), *id(h_unlocked), *id(h_closed),
        id(gv_lock_cnt), id(gv_unlock_cnt)
      );
      return {ctl};

output:
  - platform: custom
    type: float
    lambda: |-
      auto lock_motor_output = new D1Motor(id(i2c_bus), 0x30, 0);
      App.register_component(lock_motor_output);
      return {lock_motor_output};

    outputs:
      id: lock_motor

text_sensor:
  - platform: wifi_info
    ssid:
      name: $uname SSID
    bssid:
      name: $uname BSSID

  - platform: version
    name: "$uname ESPHome version"

  - platform: template
    id: txsns_state
    name: "$uname State"
    lambda: |-
      using S = LockController::State;
      auto ctl = get_lockctl(id(lockctl));
      switch (ctl->get_state()) {
        case S::open:           return {"OPEN"};
        case S::opening:        return {"OPENING"};
        case S::close:          return {"CLOSE"};
        case S::closing:        return {"CLOSING"};
        case S::wait_to_close:  return {"WAIT_TO_CLOSE"};
        case S::unknown:
        default:                return {"UNKNOWN"};
      }

binary_sensor:
  - platform: status
    name: $uname Connected

  - platform: gpio
    pin:
      number: D5
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on_off: 10ms
    id: h_closed
    name: $uname Door Closed (gpio)
    device_class: door
    internal: true
    on_press:
      # - component.update: h_closed_ha
      - lambda: |-
          auto ctl = get_lockctl(id(lockctl));
          ctl->on_door_closed();
    on_release:
      # - component.update: h_closed_ha
      - script.execute: engage_latch_scr

  - platform: template
    name: $uname Door Closed
    id: h_closed_ha
    device_class: door
    lambda: |-
      // NOTE: Home Assistant have inverted meaning of sensor: ON: open, OFF: closed
      return !id(h_closed).state;

  - platform: gpio
    pin:
      number: D6
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on_off: 10ms
    id: h_locked
    name: $uname Locked endstop
    on_press:
      - lambda: |-
          auto ctl = get_lockctl(id(lockctl));
          ctl->on_lock_endstop();

  - platform: gpio
    pin:
      number: D7
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on_off: 10ms
    id: h_unlocked
    name: $uname Unlocked endstop
    on_press:
      - lambda: |-
          auto ctl = get_lockctl(id(lockctl));
          ctl->on_unlock_endstop();

  - platform: gpio
    pin:
      number: D3
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on_off: 10ms
    id: btn_ext_open
    name: $uname External Open
    on_press:
      - script.execute: unlock_signal_scr

  - platform: gpio
    pin:
      number: D4
      mode: INPUT_PULLUP
      inverted: true
    filters:
      - delayed_on_off: 10ms
    id: btn_int_open
    name: $uname Internal Open
    on_press:
      - script.execute: internal_button_scr

sensor:
  - platform: wifi_signal
    name: "$uname WiFi Signal"
    update_interval: 10s

  - platform: uptime
    name: "$uname Uptime"

  - platform: template
    id: sns_motor_cmd
    name: $uname Motor Command
    lambda: |-
      auto ctl = get_lockctl(id(lockctl));
      return ctl->get_motor_command();

  - platform: template
    name: "$uname Lock Count"
    id: sns_lock_cnt
    icon: mdi:counter
    accuracy_decimals: 0
    unit_of_measurement: count
    lambda: !lambda |
      return float(id(gv_lock_cnt));

  - platform: template
    name: "$uname Unlock Count"
    id: sns_unlock_cnt
    icon: mdi:counter
    accuracy_decimals: 0
    unit_of_measurement: count
    lambda: !lambda |
      return float(id(gv_unlock_cnt));

switch:
  - platform: restart
    name: $uname Reboot

  - platform: template
    id: latch_mode
    name: $uname Latch Mode
    lambda: |-
      return id(gv_latch_mode);
    turn_on_action:
      - globals.set:
          id: gv_latch_mode
          value: "true"
    turn_off_action:
      - globals.set:
          id: gv_latch_mode
          value: "false"

  - platform: template
    id: lock
    name: $uname
    icon: mdi:lock_open
    # device_class: lock
    lambda: |-
      auto ctl = get_lockctl(id(lockctl));
      return ctl->get_state() != LockController::State::close;
    turn_on_action:
      - script.execute: unlock_scr
    turn_off_action:
      - script.execute: lock_scr

  - platform: template
    id: int_open_enabled
    name: $uname Internal Open Button Enabled
    icon: mdi:login
    lambda: |-
      return id(gv_int_open_enabled);
    turn_on_action:
      - globals.set:
          id: gv_int_open_enabled
          value: "true"
    turn_off_action:
      - globals.set:
          id: gv_int_open_enabled
          value: "false"

  - platform: template
    id: ext_open_enabled
    name: $uname External Open Button Enabled
    icon: mdi:fingerprint
    lambda: |-
      return id(gv_ext_open_enabled);
    turn_on_action:
      - globals.set:
          id: gv_ext_open_enabled
          value: "true"
    turn_off_action:
      - globals.set:
          id: gv_ext_open_enabled
          value: "false"

script:
  # delayed controller init
  - id: delayed_lockctl_setup_scr
    then:
      - delay: 1s
      - lambda: |-
          auto ctl = get_lockctl(id(lockctl));
          ctl->restore_state();

  - id: lockctl_on_state_change_scr
    mode: restart
    then:
      - component.update: txsns_state
      - component.update: sns_motor_cmd
      # - component.update: latch_mode
      # - component.update: lock
      - component.update: sns_lock_cnt
      - component.update: sns_unlock_cnt

  # activate locking logic
  - id: lock_scr
    then:
      - lambda: |-
          auto ctl = get_lockctl(id(lockctl));
          ctl->lock();

  # unlock the door, if latch mode is on give one minute to open
  - id: unlock_scr
    mode: restart
    then:
      - lambda: |-
          auto ctl = get_lockctl(id(lockctl));
          ctl->unlock();
      - if:
          condition:
            - switch.is_on: latch_mode
          then:
            - delay: 1min
            - script.execute: lock_scr

  # as soon as door opens we can engage locking
  - id: engage_latch_scr
    then:
      - if:
          condition:
            - switch.is_on: latch_mode
          then:
            - script.execute: lock_scr

  # called when wires to doorbell panel shorts
  - id: unlock_signal_scr
    then:
      - if:
          condition:
            switch.is_on: ext_open_enabled
          then:
            - logger.log:
                format: "external unlock called"
                level: INFO
            - script.execute: unlock_scr
          else:
            - logger.log:
                format: "external unlock called, but it is disabled"
                level: WARN

  # called when open button pressed
  - id: internal_button_scr
    then:
      - if:
          condition:
            switch.is_on: int_open_enabled
          then:
            - logger.log:
                format: "internal unlock called"
                level: INFO
            - if:
                condition:
                  lambda: |-
                    auto ctl = get_lockctl(id(lockctl));
                    auto st = ctl->get_state();
                    return st == LockController::State::open || st == LockController::State::wait_to_close;
                then:
                  - script.execute: lock_scr
                else:
                  - script.execute: unlock_scr
          else:
            - logger.log:
                format: "internal unlock called, but it is disabled"
                level: WARN
